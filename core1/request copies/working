#ifndef request_f
#define request_f

#include "pico/stdlib.h"
#include "pico/cyw43_arch.h"
#include "lwip/init.h"
#include "lwip/ip_addr.h"
#include "lwip/tcp.h"
#include "../../config.cpp"

#include <string>
namespace INTERNET {
    static char http_request[512];
    static struct tcp_pcb *client_pcb = NULL;

    bool ongoing_connection = false;
    void * result_buffor;
    uint32_t result_buffor_length;

    // ----------------------------
    // CALLBACK: when data received
    // ----------------------------
    static err_t http_recv(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err) {
        if (!p) {
            printf("Connection closed by server.\n");
            tcp_close(tpcb);
            ongoing_connection = false;
            return ERR_OK;
        }

        printf("Received %d bytes:\n", p->tot_len);
        pbuf_copy_partial(p, arg, p->tot_len, 0);
        ((char*)arg)[p->tot_len] = '\0';
        printf("%s", (char*)arg);

        pbuf_free(p);
        ongoing_connection = false;
        return ERR_OK;
    }

    // ----------------------------
    // CALLBACK: after connect
    // ----------------------------
    static err_t http_connected(void *arg, struct tcp_pcb *tpcb, err_t err) {
        if (err != ERR_OK) {
            printf("Connection failed: %d\n", err);
            ongoing_connection = false;
            return err;
        }

        printf("Connected to server.\n");
        tcp_recv(tpcb, http_recv);

        err_t e = tcp_write(tpcb, http_request, strlen(http_request), TCP_WRITE_FLAG_COPY);
        if (e != ERR_OK) {
            printf("tcp_write failed: %d\n", e);
            ongoing_connection = false;
            return e;
        }

        tcp_output(tpcb);
        ongoing_connection = false;
        return ERR_OK;
    }

    // ----------------------------
    // MAIN START
    // ----------------------------
    void http_raw_client(std::string ip, uint32_t port) {
        ip_addr_t dest_ip;
        ipaddr_aton(ip.c_str(), &dest_ip);

        client_pcb = tcp_new();
        if (!client_pcb) {
            printf("Failed to create pcb.\n");
            ongoing_connection = false;
            return;
        }

        static char recv_buf[2048]; // static so it's not on stack
        err_t err = tcp_connect(client_pcb, &dest_ip, port, http_connected);
        if (err != ERR_OK) {
            printf("Connect failed: %d\n", err);
            tcp_abort(client_pcb);
            ongoing_connection = false;
            return;
        }

        tcp_arg(client_pcb, recv_buf);
    }

    void raw_make_http_get_request(std::string ip, uint32_t port, void * a_result_buffer, uint32_t a_result_buffer_len, std::string url, std::string get_data = "") {
        ongoing_connection = true;
        result_buffor        = a_result_buffer;
        result_buffor_length = a_result_buffer_len;

        snprintf(http_request, sizeof(http_request),
            "GET %s%s%s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Connection: close\r\n"
            "\r\n",
            url.c_str(), CONFIG::PICO_REQUEST_HEADER.c_str(), get_data.c_str(), ip.c_str());
        http_raw_client(ip, port);
    }

    void simple_send_data(std::string url, std::string get_data = "") {
        ongoing_connection = true;
        result_buffor        = nullptr;
        result_buffor_length = 0;

        snprintf(http_request, sizeof(http_request),
            "GET %s%s%s HTTP/1.1\r\n"
            "Host: %s\r\n"
            "Connection: close\r\n"
            "\r\n",
            url.c_str(), CONFIG::PICO_REQUEST_HEADER.c_str(), get_data.c_str(), CONFIG::SERVER_IP.c_str());
        http_raw_client(CONFIG::SERVER_IP, CONFIG::SERVER_PORT);
    }
}

#endif
